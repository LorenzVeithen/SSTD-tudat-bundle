\hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{}\doxysection{tudat\+::propagators\+::Single\+State\+Type\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$ Class Template Reference}
\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative}\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}


Base class for calculating the state derivative model for a single type of dynamics.  




{\ttfamily \#include $<$single\+State\+Type\+Derivative.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_acbb10b6a3ae3413f136520475f93ceab}{Single\+State\+Type\+Derivative}} (const Integrated\+State\+Type integrated\+State\+Type)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a08576def80c16bfe0169693d1abc0dfc}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a08576def80c16bfe0169693d1abc0dfc}} 
virtual \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a08576def80c16bfe0169693d1abc0dfc}{$\sim$\+Single\+State\+Type\+Derivative}} ()
\begin{DoxyCompactList}\small\item\em Virtual destructor. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ae3f4427ef5aee571271cbaa23bda3cb1}{calculate\+System\+State\+Derivative}} (const Time\+Type time, const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&state\+Of\+System\+To\+Be\+Integrated, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ $>$ state\+Derivative)=0
\begin{DoxyCompactList}\small\item\em Calculates the state derivative of the system of equations for the given type of dynamics. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a39840fb71c86fcc5e70804dd6aa7683b}{clear\+State\+Derivative\+Model}} ()=0
\begin{DoxyCompactList}\small\item\em Function to clear reference/cached values of state derivative model. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a9542fa3986fabe6129f0bf5b788daeba}{update\+State\+Derivative\+Model}} (const Time\+Type current\+Time)=0
\begin{DoxyCompactList}\small\item\em Function to update the state derivative model to the current time. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ac1f76ef281c53cccc0ea66a12973b916}{convert\+Current\+State\+To\+Global\+Representation}} (const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&internal\+Solution, const Time\+Type \&time, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$ current\+Cartesian\+Local\+Soluton)=0
\item 
virtual Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ad12197357ad23bc815274f69c0c9a6c3}{convert\+From\+Output\+Solution}} (const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&output\+Solution, const Time\+Type \&time)=0
\begin{DoxyCompactList}\small\item\em Function to convert the state in the conventional form to the propagator-\/specific form. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_aeab2b2a9eae937200a5def64dcf18960}{convert\+To\+Output\+Solution}} (const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&internal\+Solution, const Time\+Type \&time, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$ current\+Cartesian\+Local\+Soluton)=0
\begin{DoxyCompactList}\small\item\em Function to convert the propagator-\/specific form of the state to the conventional form. \end{DoxyCompactList}\item 
virtual int \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_aa593f86baeb911ebaf24f849faad1867}{get\+Conventional\+State\+Size}} ()=0
\begin{DoxyCompactList}\small\item\em Function to return the size of the conventional state handled by the object. \end{DoxyCompactList}\item 
virtual int \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_af203ca28dbf9eeacb76aca2a5d4f384f}{get\+Propagated\+State\+Size}} ()
\begin{DoxyCompactList}\small\item\em Function to return the size of the propagated state handled by the object. \end{DoxyCompactList}\item 
Integrated\+State\+Type \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a2dbb19e97c9fde342788832fece0a5ff}{get\+Integrated\+State\+Type}} ()
\begin{DoxyCompactList}\small\item\em Function to return the type of dynamics for which the state derivative is calculated. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a03145882db4c90a63a72d0c855b27f11}{post\+Process\+State}} (Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$ unprocessed\+State)
\begin{DoxyCompactList}\small\item\em Function to process the state vector during propagation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a90c770ae1cc36edb43d6363416f3461f}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a90c770ae1cc36edb43d6363416f3461f}} 
virtual void {\bfseries post\+Process\+State} (Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&unprocessed\+State)
\item 
virtual bool \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a8541ff94360e103cd1157899969c6bb3}{is\+State\+To\+Be\+Post\+Processed}} ()
\begin{DoxyCompactList}\small\item\em Function to return whether the state needs to be post-\/processed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a741436a816b5d018f80f061d15fdac74}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a741436a816b5d018f80f061d15fdac74}} 
Integrated\+State\+Type \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a741436a816b5d018f80f061d15fdac74}{integrated\+State\+Type\+\_\+}}
\begin{DoxyCompactList}\small\item\em Type of dynamics for which the state derivative is calculated. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a28e844a8e7c5716d091c7504a5c98815}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a28e844a8e7c5716d091c7504a5c98815}} 
Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a28e844a8e7c5716d091c7504a5c98815}{unprocessed\+State\+\_\+}}
\begin{DoxyCompactList}\small\item\em Vector used during post-\/processing of state. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename State\+Scalar\+Type = double, typename Time\+Type = double$>$\newline
class tudat\+::propagators\+::\+Single\+State\+Type\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}

Base class for calculating the state derivative model for a single type of dynamics. 

Base class for calculating the state derivative model for a single type of dynamics (i.\+e. translational, rotational, etc.). Each type of dynamics requires its own derived class. Moreover, a specific type of propagator (Cowell, Encke, etc. for translational dynamics) may require their own further derived class, depending on the exact requirements of such a propagator. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_acbb10b6a3ae3413f136520475f93ceab}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_acbb10b6a3ae3413f136520475f93ceab}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!SingleStateTypeDerivative@{SingleStateTypeDerivative}}
\index{SingleStateTypeDerivative@{SingleStateTypeDerivative}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{SingleStateTypeDerivative()}{SingleStateTypeDerivative()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
\mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::\mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{Single\+State\+Type\+Derivative}} (\begin{DoxyParamCaption}\item[{const Integrated\+State\+Type}]{integrated\+State\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor. 

Constructor. 
\begin{DoxyParams}{Parameters}
{\em integrated\+State\+Type} & Type of dynamics for whichh the state derivative is calculated. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ae3f4427ef5aee571271cbaa23bda3cb1}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ae3f4427ef5aee571271cbaa23bda3cb1}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!calculateSystemStateDerivative@{calculateSystemStateDerivative}}
\index{calculateSystemStateDerivative@{calculateSystemStateDerivative}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{calculateSystemStateDerivative()}{calculateSystemStateDerivative()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::calculate\+System\+State\+Derivative (\begin{DoxyParamCaption}\item[{const Time\+Type}]{time,  }\item[{const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{state\+Of\+System\+To\+Be\+Integrated,  }\item[{Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ $>$}]{state\+Derivative }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Calculates the state derivative of the system of equations for the given type of dynamics. 

Calculates the state derivative of the system of equations for the given type of dynamics. The environment and acceleration models (update\+State\+Derivative\+Model) must be updated before calling this function. It returns the state derivative in the form required for the specific type of propagator used (defined by derived class). 
\begin{DoxyParams}{Parameters}
{\em time} & \mbox{\hyperlink{classtudat_1_1Time}{Time}} at which the state derivative is to be calculated. \\
\hline
{\em state\+Of\+System\+To\+Be\+Integrated} & Current state of the system, in the form that the equations are propagated (i.\+e. directly from numerical integrator) \\
\hline
{\em state\+Derivative} & Derivative of the state of the system, in the form that the equations are propagated (i.\+e. to be piped directly to numerical integrator), returned by reference. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a39840fb71c86fcc5e70804dd6aa7683b}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a39840fb71c86fcc5e70804dd6aa7683b}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!clearStateDerivativeModel@{clearStateDerivativeModel}}
\index{clearStateDerivativeModel@{clearStateDerivativeModel}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{clearStateDerivativeModel()}{clearStateDerivativeModel()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::clear\+State\+Derivative\+Model (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Function to clear reference/cached values of state derivative model. 

Function to clear reference/cached values of state derivative model, such as the current time and/or state. This function is to be implemented in each derived class 

Implemented in \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionStateDerivative_a059b6c1f916965c510e2fef88bb6799a}{tudat\+::propagators\+::\+Rotational\+Motion\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionStateDerivative_a059b6c1f916965c510e2fef88bb6799a}{tudat\+::propagators\+::\+Rotational\+Motion\+State\+Derivative$<$ double, double $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a1a4df6d3bc026a5d7d780f812fc10ba3}{tudat\+::propagators\+::\+NBody\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a1a4df6d3bc026a5d7d780f812fc10ba3}{tudat\+::propagators\+::\+NBody\+State\+Derivative$<$ double, double $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1CustomStateDerivative_a7b2ebdcc6f42cfb1cbb46291d6e80ffe}{tudat\+::propagators\+::\+Custom\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, and \mbox{\hyperlink{classtudat_1_1propagators_1_1BodyMassStateDerivative_a7c37b818e0f9b8a895dc39d374ac4633}{tudat\+::propagators\+::\+Body\+Mass\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}.

\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ac1f76ef281c53cccc0ea66a12973b916}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ac1f76ef281c53cccc0ea66a12973b916}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!convertCurrentStateToGlobalRepresentation@{convertCurrentStateToGlobalRepresentation}}
\index{convertCurrentStateToGlobalRepresentation@{convertCurrentStateToGlobalRepresentation}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{convertCurrentStateToGlobalRepresentation()}{convertCurrentStateToGlobalRepresentation()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::convert\+Current\+State\+To\+Global\+Representation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{internal\+Solution,  }\item[{const Time\+Type \&}]{time,  }\item[{Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$}]{current\+Cartesian\+Local\+Soluton }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Function to convert the propagator-\/specific form of the state to the conventional form in the global frame.

Function to convert the propagator-\/specific form of the state to the conventional form in the global frame. The conventional form is one that is typically used to represent the current state in the environment (e.\+g. Body class). For translational dynamics this is the Cartesian position and velocity). The inertial frame is typically the barycenter with J2000/\+ECLIPJ2000 orientation, but may differ depending on simulation settings 
\begin{DoxyParams}{Parameters}
{\em internal\+Solution} & State in propagator-\/specific form (i.\+e. form that is used in numerical integration). \\
\hline
{\em time} & Current time at which the state is valid. \\
\hline
{\em current\+Cartesian\+Local\+Soluton} & State (internal\+Solution), converted to the \textquotesingle{}conventional form\textquotesingle{} in inertial coordinates, that can for instance be set directly in the body object (returned by reference). \\
\hline
\end{DoxyParams}


Implemented in \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionStateDerivative_acf70dfc37b2840764c5b7811d43a58e6}{tudat\+::propagators\+::\+Rotational\+Motion\+State\+Derivative$<$ double, double $>$}}, and \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a17b2f9c92c77ced3cfa2b563878c84eb}{tudat\+::propagators\+::\+NBody\+State\+Derivative$<$ double, double $>$}}.

\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ad12197357ad23bc815274f69c0c9a6c3}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ad12197357ad23bc815274f69c0c9a6c3}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!convertFromOutputSolution@{convertFromOutputSolution}}
\index{convertFromOutputSolution@{convertFromOutputSolution}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{convertFromOutputSolution()}{convertFromOutputSolution()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::convert\+From\+Output\+Solution (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{output\+Solution,  }\item[{const Time\+Type \&}]{time }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Function to convert the state in the conventional form to the propagator-\/specific form. 

Function to convert the state in the conventional form to the propagator-\/specific form. The conventional form is one that is typically used to represent the current state in the environment (e.\+g. Body class). For translational dynamics this is the Cartesian position and velocity). 
\begin{DoxyParams}{Parameters}
{\em output\+Solution} & State in \textquotesingle{}conventional form\textquotesingle{} \\
\hline
{\em time} & Current time at which the state is valid. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
State (output\+Solution), converted to the \textquotesingle{}propagator-\/specific form\textquotesingle{} 
\end{DoxyReturn}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_aeab2b2a9eae937200a5def64dcf18960}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_aeab2b2a9eae937200a5def64dcf18960}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!convertToOutputSolution@{convertToOutputSolution}}
\index{convertToOutputSolution@{convertToOutputSolution}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{convertToOutputSolution()}{convertToOutputSolution()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::convert\+To\+Output\+Solution (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{internal\+Solution,  }\item[{const Time\+Type \&}]{time,  }\item[{Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$}]{current\+Cartesian\+Local\+Soluton }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Function to convert the propagator-\/specific form of the state to the conventional form. 

Function to convert the propagator-\/specific form of the state to the conventional form. The conventional form is one that is typically used to represent the current state in the environment (e.\+g. Body class). For translational dynamics this is the Cartesian position and velocity). In contrast to the convert\+Current\+State\+To\+Global\+Representation function, this function does not provide the state in the inertial frame, but instead provides it in the frame in which it is propagated. 
\begin{DoxyParams}{Parameters}
{\em internal\+Solution} & State in propagator-\/specific form (i.\+e. form that is used in numerical integration). \\
\hline
{\em time} & Current time at which the state is valid. \\
\hline
{\em current\+Cartesian\+Local\+Soluton} & State (internal\+Solution), converted to the \textquotesingle{}conventional form\textquotesingle{} (returned by reference). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_aa593f86baeb911ebaf24f849faad1867}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_aa593f86baeb911ebaf24f849faad1867}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!getConventionalStateSize@{getConventionalStateSize}}
\index{getConventionalStateSize@{getConventionalStateSize}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{getConventionalStateSize()}{getConventionalStateSize()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual int \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Conventional\+State\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Function to return the size of the conventional state handled by the object. 

Function to return the size of the conventional state handled by the object. This is the size of the conventional propagation state, e.\+g., size of Cartesian state for translational propagation. \begin{DoxyReturn}{Returns}
Size of the state under consideration. 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionStateDerivative_afe9ddab90e3a54aee382175cd3caadae}{tudat\+::propagators\+::\+Rotational\+Motion\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionStateDerivative_afe9ddab90e3a54aee382175cd3caadae}{tudat\+::propagators\+::\+Rotational\+Motion\+State\+Derivative$<$ double, double $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a164f88f2c4be12c243fb99a035213a66}{tudat\+::propagators\+::\+NBody\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a164f88f2c4be12c243fb99a035213a66}{tudat\+::propagators\+::\+NBody\+State\+Derivative$<$ double, double $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1CustomStateDerivative_a27d518eeac4fdf756514479b4d8a58cd}{tudat\+::propagators\+::\+Custom\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, and \mbox{\hyperlink{classtudat_1_1propagators_1_1BodyMassStateDerivative_a48cceb2e74e3e0a2f203fb1f45bebb6d}{tudat\+::propagators\+::\+Body\+Mass\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}.

\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a2dbb19e97c9fde342788832fece0a5ff}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a2dbb19e97c9fde342788832fece0a5ff}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!getIntegratedStateType@{getIntegratedStateType}}
\index{getIntegratedStateType@{getIntegratedStateType}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{getIntegratedStateType()}{getIntegratedStateType()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
Integrated\+State\+Type \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Integrated\+State\+Type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to return the type of dynamics for which the state derivative is calculated. 

Function to return the type of dynamics for which the state derivative is calculated \begin{DoxyReturn}{Returns}
Type of dynamics for which the state derivative is calculated. 
\end{DoxyReturn}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_af203ca28dbf9eeacb76aca2a5d4f384f}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_af203ca28dbf9eeacb76aca2a5d4f384f}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!getPropagatedStateSize@{getPropagatedStateSize}}
\index{getPropagatedStateSize@{getPropagatedStateSize}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{getPropagatedStateSize()}{getPropagatedStateSize()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual int \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Propagated\+State\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Function to return the size of the propagated state handled by the object. 

Function to return the size of the propagated state handled by the object. This is the size of the actual propagation state, e.\+g., size of USM7 state for translational propagation. \begin{DoxyReturn}{Returns}
Size of the propagated state under consideration. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyUnifiedStateModelQuaternionsStateDerivative_aeb2d401d6afa8ff8da105f8497352d92}{tudat\+::propagators\+::\+NBody\+Unified\+State\+Model\+Quaternions\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyUnifiedStateModelModifiedRodriguesParametersStateDerivative_a1c0d7b08d7765e3bd63ee8bbbaae753a}{tudat\+::propagators\+::\+NBody\+Unified\+State\+Model\+Modified\+Rodrigues\+Parameters\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, and \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyUnifiedStateModelExponentialMapStateDerivative_a262eb6f793d39f05a9b9b7d62a64dbc3}{tudat\+::propagators\+::\+NBody\+Unified\+State\+Model\+Exponential\+Map\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}.

\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a8541ff94360e103cd1157899969c6bb3}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a8541ff94360e103cd1157899969c6bb3}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!isStateToBePostProcessed@{isStateToBePostProcessed}}
\index{isStateToBePostProcessed@{isStateToBePostProcessed}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{isStateToBePostProcessed()}{isStateToBePostProcessed()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual bool \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::is\+State\+To\+Be\+Post\+Processed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Function to return whether the state needs to be post-\/processed. 

Function to return whether the state needs to be post-\/processed. Default value is false. \begin{DoxyReturn}{Returns}
Boolean informing whether the state needs to be post-\/processed. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionQuaternionsStateDerivative_a54fa214d24939dd96c7855814d698d85}{tudat\+::propagators\+::\+Rotational\+Motion\+Quaternions\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionModifiedRodriguesParametersStateDerivative_a073ca79ab9f04be9586b286fe53a0514}{tudat\+::propagators\+::\+Rotational\+Motion\+Modified\+Rodrigues\+Parameters\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionExponentialMapStateDerivative_a3193ea605dd74d2d07608fb4b3bc7b78}{tudat\+::propagators\+::\+Rotational\+Motion\+Exponential\+Map\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyUnifiedStateModelQuaternionsStateDerivative_aa0991141d91bd6833ffdd82f66d9696d}{tudat\+::propagators\+::\+NBody\+Unified\+State\+Model\+Quaternions\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyUnifiedStateModelModifiedRodriguesParametersStateDerivative_a3d8ea807bc9a5767226ea5d61000b771}{tudat\+::propagators\+::\+NBody\+Unified\+State\+Model\+Modified\+Rodrigues\+Parameters\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}, and \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyUnifiedStateModelExponentialMapStateDerivative_a1dbb3443fd7e77a787140fa296fe986a}{tudat\+::propagators\+::\+NBody\+Unified\+State\+Model\+Exponential\+Map\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}.

\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a03145882db4c90a63a72d0c855b27f11}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a03145882db4c90a63a72d0c855b27f11}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!postProcessState@{postProcessState}}
\index{postProcessState@{postProcessState}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{postProcessState()}{postProcessState()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::post\+Process\+State (\begin{DoxyParamCaption}\item[{Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$}]{unprocessed\+State }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Function to process the state vector during propagation. 

Function to process the state during propagation. Is especially useful for attitude states (e.\+g., normalization of quaternions and transformation to/from shadow attitude parameters). 
\begin{DoxyParams}{Parameters}
{\em unprocessed\+State} & State computed after propagation. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a9542fa3986fabe6129f0bf5b788daeba}\label{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a9542fa3986fabe6129f0bf5b788daeba}} 
\index{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}!updateStateDerivativeModel@{updateStateDerivativeModel}}
\index{updateStateDerivativeModel@{updateStateDerivativeModel}!tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$@{tudat::propagators::SingleStateTypeDerivative$<$ StateScalarType, TimeType $>$}}
\doxysubsubsection{\texorpdfstring{updateStateDerivativeModel()}{updateStateDerivativeModel()}}
{\footnotesize\ttfamily template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ \\
virtual void \mbox{\hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative}}$<$ State\+Scalar\+Type, Time\+Type $>$\+::update\+State\+Derivative\+Model (\begin{DoxyParamCaption}\item[{const Time\+Type}]{current\+Time }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Function to update the state derivative model to the current time. 

Function to update the state derivative model (i.\+e. acceleration, torque, etc. models) to the current time. Note that this function only updates the state derivative model itself, the environment models must be updated before calling this function 
\begin{DoxyParams}{Parameters}
{\em current\+Time} & \mbox{\hyperlink{classtudat_1_1Time}{Time}} to which the state derivative is to be updated. \\
\hline
\end{DoxyParams}


Implemented in \mbox{\hyperlink{classtudat_1_1propagators_1_1RotationalMotionStateDerivative_a58524509335a8ba57ec71258f510c7a4}{tudat\+::propagators\+::\+Rotational\+Motion\+State\+Derivative$<$ double, double $>$}}, and \mbox{\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a1db2b5b538eeb857e040a8744d886e61}{tudat\+::propagators\+::\+NBody\+State\+Derivative$<$ double, double $>$}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/jonashener/tudatpy\+\_\+dev/tudat-\/bundle/.\+tudat-\/documented/include/tudat/astro/propagators/single\+State\+Type\+Derivative.\+h\end{DoxyCompactItemize}
